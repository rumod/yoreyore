<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>요래됐슴당 - 청소 전후 비교</title>
  
  <!-- 라이브러리 로드 (UMD 방식) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Pretendard:wght@400;700;900&display=swap');
    
    body {
      background-color: #F8F9FA;
      font-family: 'Pretendard', sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      -webkit-tap-highlight-color: transparent;
      color: #111827;
    }
    #root { min-height: 100vh; display: flex; flex-direction: column; }
    .safe-top { padding-top: env(safe-area-inset-top); }
    .safe-bottom { padding-bottom: env(safe-area-inset-bottom); }
    
    /* 애니메이션 */
    .fade-in { animation: fadeIn 0.3s ease-in-out; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    
    .mint-shadow { box-shadow: 0 10px 25px -5px rgba(118, 215, 196, 0.4); }
  </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "vite": "https://esm.sh/vite@^7.3.1",
    "@vitejs/plugin-react": "https://esm.sh/@vitejs/plugin-react@^5.1.2"
  }
}
</script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const MINT_COLOR = '#76D7C4';
    const AppStep = {
      HOME: 'HOME',
      BEFORE_CAPTURE: 'BEFORE_CAPTURE',
      CLEANING: 'CLEANING',
      AFTER_CAPTURE: 'AFTER_CAPTURE',
      RESULT: 'RESULT'
    };

    // --- Utility Functions ---
    const resizeImage = (base64Str, maxWidth = 1200) => {
      return new Promise((resolve) => {
        const img = new Image();
        img.src = base64Str;
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;
          if (width > maxWidth) {
            height = Math.round((height * maxWidth) / width);
            width = maxWidth;
          }
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);
          resolve(canvas.toDataURL('image/jpeg', 0.85));
        };
      });
    };

    const mergeImages = async (before, after, duration) => {
      const load = (src) => new Promise(res => {
        const i = new Image(); i.crossOrigin = "anonymous"; i.onload = () => res(i); i.src = src;
      });
      
      const imgB = await load(before);
      const imgA = await load(after);
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // 결정: 가로로 붙일까 세로로 붙일까 (이미지 비율에 따라)
      const isLandscape = imgB.width > imgB.height;
      if (isLandscape) {
        canvas.width = imgB.width;
        canvas.height = imgB.height + imgA.height;
        ctx.drawImage(imgB, 0, 0);
        ctx.drawImage(imgA, 0, imgB.height);
      } else {
        canvas.width = imgB.width + imgA.width;
        canvas.height = imgB.height;
        ctx.drawImage(imgB, 0, 0);
        ctx.drawImage(imgA, imgB.width, 0);
      }

      // 워터마크/타임스탬프
      const now = new Date();
      const timeStr = `${now.getFullYear()}.${now.getMonth()+1}.${now.getDate()} | ${duration}분 소요 | 요래됐슴당 ✨`;
      const fontSize = Math.round(canvas.height * 0.035);
      ctx.font = `bold ${fontSize}px Pretendard, sans-serif`;
      
      const textWidth = ctx.measureText(timeStr).width;
      const padding = fontSize;
      const rectW = textWidth + padding * 2;
      const rectH = fontSize * 1.8;
      const x = (canvas.width - rectW) / 2;
      const y = canvas.height - rectH - padding;

      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      if (ctx.roundRect) {
        ctx.beginPath(); ctx.roundRect(x, y, rectW, rectH, rectH/2); ctx.fill();
      } else {
        ctx.fillRect(x, y, rectW, rectH);
      }
      
      ctx.fillStyle = '#FFFFFF';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(timeStr, x + rectW/2, y + rectH/2 + 2);

      return canvas.toDataURL('image/jpeg', 0.9);
    };

    // --- Sub-Components ---
    const CameraView = ({ mode, onCapture, onBack, beforeImg }) => {
      const videoRef = useRef(null);
      const [isGhost, setIsGhost] = useState(true);
      const [error, setError] = useState(null);

      useEffect(() => {
        let stream = null;
        navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
          .then(s => { stream = s; if (videoRef.current) videoRef.current.srcObject = s; })
          .catch(e => setError("카메라 권한이 필요합니다."));
        return () => stream?.getTracks().forEach(t => t.stop());
      }, []);

      const capture = () => {
        const v = videoRef.current;
        const canvas = document.createElement('canvas');
        canvas.width = v.videoWidth;
        canvas.height = v.videoHeight;
        canvas.getContext('2d').drawImage(v, 0, 0);
        onCapture(canvas.toDataURL('image/jpeg', 0.9));
      };

      return (
        <div className="fixed inset-0 bg-black z-50 flex flex-col overflow-hidden">
          <div className="absolute top-0 left-0 right-0 p-6 flex justify-between items-center z-40 safe-top">
            <button onClick={onBack} className="text-white p-3 bg-black/40 rounded-full backdrop-blur-md">
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="3" d="M15 19l-7-7 7-7" /></svg>
            </button>
            <div className="bg-black/40 px-6 py-2 rounded-full backdrop-blur-md border border-white/20">
               <span className="text-white font-black text-sm">{mode === 'before' ? '청소 전' : '청소 후'}</span>
            </div>
            <div className="w-12" />
          </div>
          
          <div className="flex-1 relative flex items-center justify-center">
            {error ? <p className="text-white font-bold">{error}</p> : <video ref={videoRef} autoPlay playsInline muted className="w-full h-full object-cover" />}
            {mode === 'after' && beforeImg && isGhost && (
              <img src={beforeImg} className="absolute inset-0 w-full h-full object-cover opacity-30 mix-blend-lighten pointer-events-none" />
            )}
          </div>

          <div className="h-44 flex justify-between items-center px-10 bg-black safe-bottom border-t border-white/10">
            {mode === 'after' ? (
              <button onClick={() => setIsGhost(!isGhost)} className={`w-14 h-14 rounded-2xl border-2 flex flex-col items-center justify-center transition-all ${isGhost ? 'bg-white/20 border-white/50 text-white' : 'border-white/20 text-white/40'}`}>
                <span className="text-[9px] font-black tracking-tighter">GHOST</span>
                <span className="text-[8px] font-bold">{isGhost ? 'ON' : 'OFF'}</span>
              </button>
            ) : <div className="w-14" />}
            
            <button onClick={capture} className="w-24 h-24 border-4 border-white/30 rounded-full flex items-center justify-center active:scale-90 transition-transform shadow-2xl">
              <div className="w-20 h-20 bg-white rounded-full"></div>
            </button>
            
            <label className="w-14 h-14 rounded-2xl bg-white/10 border border-white/20 flex flex-col items-center justify-center text-white cursor-pointer active:bg-white/20">
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/></svg>
              <input type="file" className="hidden" accept="image/*" onChange={async (e) => {
                const file = e.target.files[0];
                if (file) {
                  const reader = new FileReader();
                  reader.onload = (ev) => onCapture(ev.target.result);
                  reader.readAsDataURL(file);
                }
              }} />
            </label>
          </div>
        </div>
      );
    };

    // --- Main App ---
    const App = () => {
      const [step, setStep] = useState(AppStep.HOME);
      const [session, setSession] = useState({ beforeImg: null, afterImg: null, startTime: null, mergedImg: null });

      useEffect(() => {
        const saved = localStorage.getItem('yorae_v1');
        if (saved) {
          const parsed = JSON.parse(saved);
          setSession(parsed);
          if (parsed.mergedImg) setStep(AppStep.RESULT);
          else if (parsed.beforeImg) setStep(AppStep.CLEANING);
        }
      }, []);

      useEffect(() => {
        localStorage.setItem('yorae_v1', JSON.stringify(session));
      }, [session]);

      const handleBefore = async (img) => {
        const resized = await resizeImage(img);
        setSession({ ...session, beforeImg: resized, startTime: Date.now(), mergedImg: null });
        setStep(AppStep.CLEANING);
      };

      const handleAfter = async (img) => {
        const resized = await resizeImage(img);
        const duration = Math.round((Date.now() - session.startTime) / 60000);
        const merged = await mergeImages(session.beforeImg, resized, duration);
        setSession({ ...session, afterImg: resized, mergedImg: merged });
        setStep(AppStep.RESULT);
      };

      const reset = () => {
        if(confirm("모든 데이터를 삭제하고 처음으로 돌아갈까요?")) {
          localStorage.removeItem('yorae_v1');
          setSession({ beforeImg: null, afterImg: null, startTime: null, mergedImg: null });
          setStep(AppStep.HOME);
        }
      };

      return (
        <div className="max-w-md mx-auto min-h-screen bg-white shadow-2xl flex flex-col relative">
          {step === AppStep.HOME && (
            <div className="flex-1 flex flex-col items-center justify-center p-12 text-center bg-[#FDFDFD] fade-in">
              <span className="text-8xl mb-6 animate-bounce">✨</span>
              <h1 className="text-5xl font-black mb-3 text-gray-900 tracking-tighter">요래됐슴당</h1>
              <p className="text-gray-500 font-bold mb-16 leading-relaxed">이랬는데... 요래됐슴당!<br/>변화의 순간을 기록해보세요.</p>
              <div className="w-full space-y-4">
                <button onClick={() => setStep(AppStep.BEFORE_CAPTURE)} style={{ backgroundColor: MINT_COLOR }} className="w-full py-5 rounded-[2rem] text-white text-2xl font-black mint-shadow active:scale-95 transition-all">기록 시작하기</button>
                {session.beforeImg && !session.mergedImg && (
                  <button onClick={() => setStep(AppStep.CLEANING)} className="w-full py-4 rounded-[2rem] border-2 border-gray-100 font-black text-gray-800">진행 중인 기록 이어하기</button>
                )}
              </div>
            </div>
          )}

          {step === AppStep.CLEANING && (
            <div className="flex-1 flex flex-col items-center justify-center p-8 bg-white fade-in">
              <div className="relative mb-12">
                <div className="w-72 h-72 rounded-[3.5rem] overflow-hidden shadow-2xl border-8 border-gray-50">
                  <img src={session.beforeImg} className="w-full h-full object-cover grayscale-[0.2]" />
                </div>
                <div className="absolute inset-0 flex items-center justify-center bg-black/20 rounded-[3.5rem]">
                  <p className="text-white font-black text-2xl drop-shadow-lg">이랬는데...</p>
                </div>
              </div>
              <h2 className="text-3xl font-black mb-12 text-gray-900">열심히 청소 중... ✨</h2>
              <button onClick={() => setStep(AppStep.AFTER_CAPTURE)} style={{ backgroundColor: MINT_COLOR }} className="w-full py-5 rounded-[2rem] text-white text-2xl font-black mint-shadow active:scale-95 transition-all">청소 끝! 촬영하기</button>
              <button onClick={reset} className="mt-8 text-gray-400 font-bold underline text-sm">기록 취소하기</button>
            </div>
          )}

          {step === AppStep.RESULT && (
            <div className="flex-1 flex flex-col p-8 fade-in bg-white overflow-y-auto">
              <div className="text-center my-8">
                <p className="font-black text-gray-400 mb-1">이랬는데...</p>
                <h2 className="text-4xl font-black" style={{ color: MINT_COLOR }}>요래됐슴당!</h2>
              </div>
              <div className="rounded-[2.5rem] overflow-hidden shadow-2xl border-4 border-gray-50 bg-gray-50 mb-10 aspect-[3/4] flex items-center justify-center">
                <img src={session.mergedImg} className="w-full h-full object-contain" />
              </div>
              <div className="space-y-4 mb-10">
                <button onClick={() => {
                  const link = document.createElement('a');
                  link.href = session.mergedImg;
                  link.download = `yorae_${Date.now()}.jpg`;
                  link.click();
                }} style={{ backgroundColor: MINT_COLOR }} className="w-full py-5 rounded-2xl text-white text-xl font-black shadow-xl active:scale-95 transition-all">이미지 저장하기</button>
                <button onClick={() => setStep(AppStep.HOME)} className="w-full py-5 rounded-2xl border-2 border-gray-100 font-black text-gray-900 active:bg-gray-50 transition-all">처음으로</button>
                <button onClick={reset} className="w-full py-2 text-gray-300 font-bold text-xs underline">새로 만들기</button>
              </div>
            </div>
          )}

          {(step === AppStep.BEFORE_CAPTURE || step === AppStep.AFTER_CAPTURE) && (
            <CameraView 
              mode={step === AppStep.BEFORE_CAPTURE ? 'before' : 'after'}
              onCapture={step === AppStep.BEFORE_CAPTURE ? handleBefore : handleAfter}
              onBack={() => setStep(step === AppStep.BEFORE_CAPTURE ? AppStep.HOME : AppStep.CLEANING)}
              beforeImg={session.beforeImg}
            />
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>